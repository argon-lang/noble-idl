package dev.argon.nobleidl.sbtnobleidl

import dev.argon.esexpr.generator.ESExprGeneratorProcessor
import sbt.Keys.*
import sbt.*
import sbt.librarymanagement.{DependencyResolution, UnresolvedWarningConfiguration, UpdateConfiguration}

import java.io.File
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import javax.tools.{DiagnosticCollector, JavaFileObject, ToolProvider}
import scala.jdk.CollectionConverters.*
import scala.sys.process.Process
import scala.util.Using

object NobleIDLPlugin extends AutoPlugin {

  object autoImport {
    val generateNobleIdl = taskKey[Seq[File]]("Generates sources using the Noble IDL compiler")
    val runESExprJavaAnnotationProcessor = taskKey[Seq[File]]("Run the annotation processor for ESExpr Java")
    val nobleIdlSourceDirectories = settingKey[Seq[File]]("Directories containing Noble IDL sources")

    val generateNobleIdlScala = settingKey[Boolean]("Enable generation of Noble IDL sources with the Scala backend")
    val generateNobleIdlScalaJs = settingKey[Boolean]("Enable generation of Noble IDL sources with the Scala.js backend")
    val generateNobleIdlJava = settingKey[Boolean]("Enable generation of Noble IDL sources with the Java backend")

    val generateNobleIdlJavaAdapters = settingKey[Boolean]("Enable generation conversion methods between Scala and Java types")
    val generateNobleIdlJsAdapters = settingKey[Boolean]("Enable generation conversion methods between Scala and Scala.js types")
    val generateNobleIdlGraalJsAdapters = settingKey[Boolean]("Enable generation conversion methods between Java and GraalJS values")

    val nobleIdlGeneratedResources = settingKey[File]("Output directory for Scala sources generated by Noble IDL")
    val nobleIdlGeneratedSourcesScala = settingKey[File]("Output directory for Scala sources generated by Noble IDL")
    val esexprAnnotationProcessorGeneratedSourcesJava = settingKey[File]("Output directory for ESExpr Java annotation processor")
  }

  import autoImport._

  override def projectSettings: Seq[Def.Setting[_]] =
    Seq(
      Compile / generateNobleIdl := {
        val s = streams.value
        val outDir = (Compile / nobleIdlGeneratedSourcesScala).value
        val resourceDir = (Compile / nobleIdlGeneratedResources).value

        val inputDirs = (Compile / nobleIdlSourceDirectories).value
        val sourceDirs = (Compile / unmanagedSourceDirectories).value

        val javaArgs = javaOptions.value

        val depRes = (Compile / dependencyResolution).value

        val depCP = (Compile / dependencyClasspathAsJars).value

        val generateScala = (Compile / generateNobleIdlScala).value
        val generateScalaJs = (Compile / generateNobleIdlScalaJs).value
        val generateJava = (Compile / generateNobleIdlJava).value

        val generateJavaAdapters = (Compile / generateNobleIdlJavaAdapters).value
        val generateJsAdapters = (Compile / generateNobleIdlJsAdapters).value
        val generateGraalJsAdapters = (Compile / generateNobleIdlGraalJsAdapters).value

        val f = FileFunction.cached(s.cacheDirectory / "generate-nobleidl") { (in: Set[File]) =>
          IO.delete(outDir)
          IO.createDirectory(outDir)

          val generatorCP = resolveJar(depRes, s).map(_.toString).mkString(File.pathSeparator)

          s.log.info(s"Generating sources from NobleIDL schema in ${outDir}")

          IO.createDirectory(outDir)

          val javaExe = (javaHome.value.getOrElse(file(sys.props("java.home"))) / "bin" / "java").toString

          val args =
            Seq(javaExe) ++
              javaArgs ++
              Seq(
                "-cp",
                generatorCP,
                "nobleidl.compiler.ScalaNobleIDLCompiler",
              ) ++
              (if(generateScala) Seq("--scala") else Seq()) ++
              (if(generateScalaJs) Seq("--scalajs") else Seq()) ++
              (if(generateJava) Seq("--java") else Seq()) ++
              (if(generateJavaAdapters) Seq("--java-adapters") else Seq()) ++
              (if(generateJsAdapters) Seq("--js-adapters") else Seq()) ++
              (if(generateGraalJsAdapters) Seq("--graal-js-adapters") else Seq()) ++
              inputDirs.filter(_.exists()).flatMap { inputDir => Seq("--input", inputDir.toString) } ++
              sourceDirs.filter(_.exists()).flatMap { sourceDir => Seq("--java-source", sourceDir.toString) } ++
              Seq(
                "--output",
                outDir.toString,
                "--resource-output",
                resourceDir.toString,
              ) ++
              depCP.filter(_.data.exists()).flatMap { f => Seq("--library", f.data.toString) }


          s.log.debug("Noble IDL Args: " + args.mkString(" "))

          val exitCode = Process(args).!(s.log)

          if (exitCode != 0) {
            throw new Exception(s"ESExpr Generator failed with exit code ${exitCode}")
          }

          outDir.allPaths.filter(_.isFile).get().toSet
        }

        val inputFiles = inputDirs.allPaths.filter(f => f.isFile && f.getName.endsWith(".nidl")).get().toSet

        f(inputFiles).toSeq
      },
      Compile / runESExprJavaAnnotationProcessor := {
        val s = streams.value
        val outDir = (Compile / esexprAnnotationProcessorGeneratedSourcesJava).value

        val unmanagedSourceFiles = (Compile / unmanagedSources).value
        val nobleIdlOutput = (Compile / generateNobleIdl).value

        val javacArgs = javacOptions.value

        val depCP = (Compile / dependencyClasspathAsJars).value

        val generateJava = (Compile / generateNobleIdlJava).value

        if(generateJava) {
          val f = FileFunction.cached(s.cacheDirectory / "esexpr-annotation-processor") { (in: Set[File]) =>
            IO.delete(outDir)
            IO.createDirectory(outDir)

            s.log.info(s"Running ESExpr Annotation processor in ${outDir}")


            val compiler = ToolProvider.getSystemJavaCompiler

            val diagnostics = new DiagnosticCollector[JavaFileObject]

            Using.resource(compiler.getStandardFileManager(diagnostics, null, StandardCharsets.UTF_8)) { fileManager =>
              val sourceFiles = in.toArray

              val compilationUnits = fileManager.getJavaFileObjects(sourceFiles *)

              val args = new java.util.ArrayList[String]()
              args.add("-proc:only")

              val classpath = depCP.view.map(_.data).mkString(java.io.File.pathSeparator)
              s

              args.add("--module-path")
              args.add(classpath)

              args.add("-s")
              args.add(outDir.toString)

              val task = compiler.getTask(
                java.io.Writer.nullWriter,
                fileManager,
                diagnostics,
                args,
                null,
                compilationUnits
              )

              task.setProcessors(Seq(new ESExprGeneratorProcessor()).asJava)

              if(!task.call()) {
                val errors: String = diagnostics.getDiagnostics.asScala.map(diag => diag.toString).mkString(java.lang.System.lineSeparator)
                throw new RuntimeException("Noble IDL Annotation processing failure" + java.lang.System.lineSeparator + errors)
              }
            }


            outDir.allPaths.filter(_.isFile).get().toSet
          }

          val inputFiles =
            (unmanagedSourceFiles.view ++ nobleIdlOutput.view)
              .filter(f => f.isFile && f.getName.endsWith(".java"))
              .toSet

          if(inputFiles.isEmpty) Seq()
          else f(inputFiles).toSeq
        }
        else {
          Seq()
        }
      },

      Compile / sourceGenerators += Def.task {
        (Compile / generateNobleIdl).value
      }.taskValue,

      Compile / sourceGenerators += Def.task {
        (Compile / runESExprJavaAnnotationProcessor).value
      }.taskValue,

      Compile / resourceGenerators += Def.task {
        val _ = (Compile / generateNobleIdl).value
        ((Compile / nobleIdlGeneratedResources).value ** "*.nidl").get()
      }.taskValue,

      Compile / generateNobleIdlScala := true,
      Compile / generateNobleIdlScalaJs := false,
      Compile / generateNobleIdlJava := false,

      Compile / generateNobleIdlJavaAdapters := false,
      Compile / generateNobleIdlJsAdapters := false,
      Compile / generateNobleIdlGraalJsAdapters := false,

      Compile / nobleIdlGeneratedResources := resourceManaged.value / "nobleidl",
      Compile / managedResourceDirectories += (Compile / nobleIdlGeneratedResources).value,

      Compile / nobleIdlGeneratedSourcesScala := sourceManaged.value / "nobleidl",
      Compile / managedSourceDirectories += (Compile / nobleIdlGeneratedSourcesScala).value,

      Compile / esexprAnnotationProcessorGeneratedSourcesJava := sourceManaged.value / "esexpr-annotation-processor",


      Compile / nobleIdlSourceDirectories := Seq(baseDirectory.value / "src/main/nobleidl"),
    )

  private def resolveJar(res: DependencyResolution, s: TaskStreams): Seq[File] = {
    val moduleDesc = res.wrapDependencyInModule("dev.argon.nobleidl" % "nobleidl-scala-compiler_3" % "0.1.0-SNAPSHOT")
    val updateConfig = UpdateConfiguration()
      .withMissingOk(false)

    val updateReport = res.update(moduleDesc, updateConfig, UnresolvedWarningConfiguration(), s.log)
      .left.map(warning => throw new RuntimeException("Failed to resolve Noble IDL Compiler", warning.resolveException))
      .toTry
      .get

    updateReport.allFiles
  }
}
