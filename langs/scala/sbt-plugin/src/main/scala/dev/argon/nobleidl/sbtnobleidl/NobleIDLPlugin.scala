package dev.argon.nobleidl.sbtnobleidl

import sbt.Keys.*
import sbt.*
import sbt.librarymanagement.{DependencyResolution, UnresolvedWarningConfiguration, UpdateConfiguration}

import java.io.File
import scala.sys.process.Process

object NobleIDLPlugin extends AutoPlugin {

  object autoImport {
    val generateNobleIdl = taskKey[Seq[File]]("Generates sources using the Noble IDL compiler")
    val nobleIdlSourceDirectories = settingKey[Seq[File]]("Directories containing Noble IDL sources")

    val generateNobleIdlScala = settingKey[Boolean]("Enable generation of Noble IDL sources with the Scala backend")
    val generateNobleIdlScalaJs = settingKey[Boolean]("Enable generation of Noble IDL sources with the Scala.js backend")

    val generateNobleIdlJavaAdapters = settingKey[Boolean]("Enable generation conversion methods between Scala and Java types")
    val generateNobleIdlJsAdapters = settingKey[Boolean]("Enable generation conversion methods between Scala and Scala.js types")

    val nobleIdlGeneratedResources = settingKey[File]("Output directory for Scala sources generated by Noble IDL")
    val nobleIdlGeneratedSourcesScala = settingKey[File]("Output directory for Scala sources generated by Noble IDL")
  }

  import autoImport._

  override def projectSettings: Seq[Def.Setting[_]] =
    Seq(
      Compile / generateNobleIdl := {
        val s = streams.value
        val outDir = (Compile / nobleIdlGeneratedSourcesScala).value
        val resourceDir = (Compile / nobleIdlGeneratedResources).value

        val inputDirs = (Compile / nobleIdlSourceDirectories).value
        val sourceDirs = (Compile / unmanagedSourceDirectories).value

        val javaArgs = javaOptions.value

        val depRes = (Compile / dependencyResolution).value

        val depCP = (Compile / dependencyClasspathAsJars).value

        val generateScala = (Compile / generateNobleIdlScala).value
        val generateScalaJs = (Compile / generateNobleIdlScalaJs).value

        val generateJavaAdapters = (Compile / generateNobleIdlJavaAdapters).value
        val generateJsAdapters = (Compile / generateNobleIdlJsAdapters).value

        val f = FileFunction.cached(s.cacheDirectory / "generate-nobleidl") { (in: Set[File]) =>
          IO.delete(outDir)
          IO.createDirectory(outDir)

          val generatorCP = resolveJar(depRes, s).map(_.toString).mkString(File.pathSeparator)

          s.log.info(s"Generating sources from NobleIDL schema in ${outDir}")

          IO.createDirectory(outDir)

          val args =
            Seq("java") ++
              javaArgs ++
              Seq(
                "-cp",
                generatorCP,
                "nobleidl.compiler.ScalaNobleIDLCompiler",
              ) ++
              (if(generateScala) Seq("--scala") else Seq()) ++
              (if(generateScalaJs) Seq("--scalajs") else Seq()) ++
              (if(generateJavaAdapters) Seq("--java-adapters") else Seq()) ++
              (if(generateJsAdapters) Seq("--js-adapters") else Seq()) ++
              inputDirs.filter(_.exists()).flatMap { inputDir => Seq("--input", inputDir.toString) } ++
              sourceDirs.filter(_.exists()).flatMap { sourceDir => Seq("--java-source", sourceDir.toString) } ++
              Seq(
                "--output",
                outDir.toString,
                "--resource-output",
                resourceDir.toString,
              ) ++
              depCP.filter(_.data.exists()).flatMap { f => Seq("--library", f.data.toString) }


          s.log.debug("Noble IDL Args: " + args.mkString(" "))

          val exitCode = Process(args).!(s.log)

          if (exitCode != 0) {
            throw new Exception(s"ESExpr Generator failed with exit code ${exitCode}")
          }

          outDir.allPaths.filter(_.isFile).get().toSet
        }

        val inputFiles = inputDirs.allPaths.filter(f => f.isFile && f.getName.endsWith(".nidl")).get().toSet

        f(inputFiles).toSeq
      },

      Compile / sourceGenerators += Def.task {
        (Compile / generateNobleIdl).value
      }.taskValue,

      Compile / generateNobleIdlScala := true,
      Compile / generateNobleIdlScalaJs := false,

      Compile / generateNobleIdlJavaAdapters := false,
      Compile / generateNobleIdlJsAdapters := false,

      Compile / nobleIdlGeneratedResources := resourceManaged.value / "nobleidl",
      Compile / managedResourceDirectories += (Compile / nobleIdlGeneratedResources).value,

      Compile / nobleIdlGeneratedSourcesScala := sourceManaged.value / "nobleidl",
      Compile / managedSourceDirectories += (Compile / nobleIdlGeneratedSourcesScala).value,

      Compile / nobleIdlSourceDirectories := Seq(baseDirectory.value / "src/main/nobleidl"),
    )

  private def resolveJar(res: DependencyResolution, s: TaskStreams): Seq[File] = {
    val moduleDesc = res.wrapDependencyInModule("dev.argon.nobleidl" % "nobleidl-scala-compiler_3" % "0.1.0-SNAPSHOT")
    val updateConfig = UpdateConfiguration()
      .withMissingOk(false)

    val updateReport = res.update(moduleDesc, updateConfig, UnresolvedWarningConfiguration(), s.log)
      .left.map(warning => throw new RuntimeException("Failed to resolve Noble IDL Compiler", warning.resolveException))
      .toTry
      .get

    updateReport.allFiles
  }
}
